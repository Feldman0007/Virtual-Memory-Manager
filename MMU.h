/*
===============================================================================================================================================================================
Memory Management Unit 
===============================================================================================================================================================================

The MMU class provides methods for extracting page number and displacement, accessing and storing data in RAM, reading and printing from RAM, trapping (if page fault occurs),
and managing the TLB.

Purpose:
	The MMU maps logical addresses generated by the CPU to physical addresses at run time (translates), validates address space, and traps when a page fault is detected.

Roles and Responsibilities:
	MMU receives logical addresses and maps them to physical memory.It stores values used to calculate resulting TLB hit rate and Page Fault Rate.
	It regulates the system's access to RAM.
	Issues traps (page faults).
	It acts as a bridge of communication among components of our program.

===============================================================================================================================================================================
*/
#pragma once
#include <iostream>
#include <string>
#include <sstream>

#include "Configuration.hpp"
#include "BackingStore.h"
#include "Address.h"
#include "RAM.h"
#include "ProcessControlBlock.h"
#include "TLB.h"

using namespace std;

#ifndef MMU_H
#define MMU_H

class MMU { 
private:
	TLB tlb;
	Address currentAddress; // instance of the address of the processes' current page request
//	addressSpaceIdentifier asid;  would be a private member, but it wasn't really in the scope of the project

//counters
	uint32_t page_access_count = 0;
	uint32_t page_in_faults = 0;
	uint32_t tlb_access_count = 0;
	uint32_t tlb_faults = 0;
	
public: 	
//Address management
	void processAddress(uint32_t intAddr);
	Address getAddress();
//  void validateAddressSpace(); this would be a method, but it wasn't really in the scope of the project since we are only dealing with the single process that is making many page requests
	void trap(bool validBit, uint32_t pgNum);
	
//TLB management
	hitStatus checkTLB(uint32_t pageNum);
	uint32_t tlb_get_frame(uint32_t pageNum);
	void updateTLB(uint32_t frameNum, uint32_t  pageNum, hitStatus isHit);
	void clearTLB();

//RAM access
	void read_and_print(RAM & r, uint32_t frameNumber, uint32_t frameOffset);
	void storeInRam(RAM & r, uint32_t freeFrame, char * frameOfData);
	
//counter management
	void update_page_access_count();
	void update_page_in_faults();
	void update_tlb_access_count();
	void update_tlb_faults();
	void calculateTLBRate();
	void calculatePageFaultRate();
};


#endif
