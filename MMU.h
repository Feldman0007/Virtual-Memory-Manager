#pragma once
#include <iostream>
#include <string>
#include <sstream>

#include "Configuration.hpp"
#include "BackingStore.h"
#include "Address.h"
#include "RAM.h"
#include "ProcessControlBlock.h"
#include "TLB.h"

using namespace std;

#ifndef MMU_H
#define MMU_H

/*
------------------------------------------------------------ Memory Management Unit -------------------------------------------------------------
The MMU class provides methods for extracting page number and displacement, accessing and storing data in RAM, reading and printing from RAM, trapping (if page fault occurs),
																																			and managing the TLB.

Purpose:
	The MMU maps logical addresses generated by the CPU to physical addresses at run time (translates), validates address space, and traps when a page fault is detected. 
Roles and Responsibilities:
	MMU receives logical addresses (page requests) and regulates access to ram.	It stores values used to calculate resulting TLB hit rate and Page Fault Rate. 
	MMU essentially acts as a bridge of communication among components of our program.
	It is to oversees and regulates the process's use of Ram
	It also translate addresses among systems
	Do the validation and traps.
-------------------------------------------------------------------------------------------------------------------------------------------------
*/

struct PageFault {
	uint32_t faultingPage;
};

class MMU { 
private:
	Address currentAddress; // Instance of the address we are currently working with
	TLB tlb;

	uint32_t page_access_count = 0;
	uint32_t page_in_faults = 0;
	uint32_t tlb_access_count = 0;
	uint32_t tlb_faults = 0;
	
public: 
	void processAddress(uint32_t intAddr);
	Address getAddress();
	
	hitStatus checkTLB(uint32_t pageNum);
	uint32_t tlb_get_frame(uint32_t pageNum);
	void updateTLB(uint32_t frameNum, uint32_t  pageNum, hitStatus isHit);
	void read_and_print(RAM & r, uint32_t frameNumber, uint32_t frameOffset);
	void storeInRam(RAM & r, uint32_t freeFrame, char * frameOfData);
	void trap(bool validBit, uint32_t pgNum);
	void clearTLB();
	//void validateAddressSpace(); this would be a method, but it wasn't really in the scope of the propject since we are only dealing with the single process that is making many page requests

	void update_page_access_count();
	void update_page_in_faults();
	void update_tlb_access_count();
	void update_tlb_faults();
	void calculateTLBRate();
	void calculatePageFaultRate();
};


#endif
